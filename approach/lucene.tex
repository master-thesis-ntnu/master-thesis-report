\subsection{Lucene Architecture}
The Lucene implementation were done using version 6.4.0 of Lucene \cite{lucene-documentation}.

Most search engines strives to hold the data in memory.
To achieve the performance desired by Lucene the whole index is kept in memory.

The tag field is stored with information about document frequency for each term.
The document frequency is required to calculate the KL score for each term.

Minimal Java optimizations


Even though the Lucen implementation delivered promising results, Lucene in itself is not scalable.
As one of the research questions

\texttt{IndexOptions.DOCS\_AND\_FREQS}

\subsubsection{Lucene Notes}
- Discuss java methods to retrieve term frequency from the inverted index

\subsubsection{Indexing}
Lucene have multiple data types which may be stored,
but the types used in this implementation were \texttt{StringField}, \texttt{LongPoint} and \texttt{TextField}.
All the photo tags were indexed using the \texttt{TextField}.
The two fields \texttt{TextField} and \texttt{StringField} are quite similar,
but have some important differences.
Listing \ref{lst:lucene-string-field} displays the \texttt{StringField} configuration code from Lucene's Github repository\footnote{\url{https://github.com/apache/lucene-solr/blob/master/lucene/core/src/java/org/apache/lucene/document/StringField.java}}.
The first function \texttt{setIndexOptions(IndexOptions.DOCS)},
configures the inverted index to only store which documents contains the term.
Term frequencies and vector are not stored with this option.
\texttt{setStored(true)} tells the Lucene index to store the original value.
Lastly, the function \texttt{setTokenized(false)} informs Lucene to store the string value as a single token.

\begin{lstlisting}[language=java, caption={Lucene's \texttt{StringField} index configuration.}, label={lst:lucene-string-field}]
  setStored(true);
  setTokenized(false);
  setIndexOptions(IndexOptions.DOCS);
\end{lstlisting}

Listing \ref{lst:lucene-text-field} shows the \texttt{TextField} configuration code from Lucene's Github repository\footnote{\url{https://github.com/apache/lucene-solr/blob/master/lucene/core/src/java/org/apache/lucene/document/StringField.java}}.
The difference between the \texttt{StringField} and the \texttt{TextField} code are line two and three.
\texttt{setTokenized(true)} tells the Lucene analyzer emit a token for each word in the given string.
Most important is line three which tells Lucene to store data about which documents contains a given term,
a given terms frequncy in each document and the terms position in the original text.
Calculating the KL-score of a term requires the terms total frequency across all documents.

\begin{lstlisting}[language=java, caption={Lucene's \texttt{TextField} index configuration.}, label={lst:lucene-text-field}]
    setStored(true);
    setTokenized(true);
    setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
\end{lstlisting}

\subsubsection{Query Expanded Search}
Figure shows a sequence diagram for the Lucene implementation.
As the sequence diagram shows, the java program first recieves the query.
The query is then sent to the Lucene index as a multi term query.
Lucene then returns the top-k documents from the index.



\begin{figure}[h!]
  \centering \includegraphics[width=0.9\linewidth]{img/sequence-diagram-lucene.png}
  \caption{Sequence diagram for the Lucene implementation.}
  \label{fig:sequence-diagram-lucene}
\end{figure}
